-- WARNING: This schema is for context only and is not meant to be run.
-- Table order and constraints may not be valid for execution.

CREATE TABLE public.contacts (
  id bigint GENERATED ALWAYS AS IDENTITY NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  name text,
  email text,
  number text,
  birthday date,
  cost real,
  isblacklist boolean NOT NULL,
  isdeleted boolean NOT NULL,
  isfavorite boolean NOT NULL,
  workingfrom date,
  workingto date,
  user_id bigint,
  team_id BIGINT NULL REFERENCES public.team(id),
  CONSTRAINT contacts_pkey PRIMARY KEY (id)
);
CREATE TABLE public.hasskills (
  id bigint GENERATED ALWAYS AS IDENTITY NOT NULL,
  fk_contacts_id bigint,
  fk_skills_id smallint,
  user_id bigint,
  CONSTRAINT hasskills_pkey PRIMARY KEY (id),
  CONSTRAINT HasSkills_FK_Skills_id_fkey FOREIGN KEY (fk_skills_id) REFERENCES public.skills(id),
  CONSTRAINT HasSkills_FK_Contacts_id_fkey FOREIGN KEY (fk_contacts_id) REFERENCES public.contacts(id)
);
CREATE TABLE public.object (
  id bigint GENERATED ALWAYS AS IDENTITY NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  name text,
  location text,
  description text,
  startdate date,
  enddate date,
  isactive boolean,
  user_id bigint,
  team_id BIGINT NULL REFERENCES public.team(id),
  CONSTRAINT object_pkey PRIMARY KEY (id)
);
CREATE TABLE public.review (
  id bigint GENERATED ALWAYS AS IDENTITY NOT NULL,
  fk_workingon_id bigint,
  rating smallint,
  reviewtext text,
  created_at timestamp with time zone,
  user_id bigint,
  CONSTRAINT review_pkey PRIMARY KEY (id),
  CONSTRAINT Review_FK_WorkingOn_id_fkey FOREIGN KEY (fk_workingon_id) REFERENCES public.workingon(id)
);
CREATE TABLE public.skills (
  id smallint GENERATED ALWAYS AS IDENTITY NOT NULL,
  name character varying,
  user_id bigint,
  CONSTRAINT skills_pkey PRIMARY KEY (id)
);
CREATE TABLE public.workingon (
  id bigint GENERATED ALWAYS AS IDENTITY NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  ispaid boolean NOT NULL,
  fk_contact_id bigint,
  fk_object_id bigint,
  user_id bigint,
  CONSTRAINT workingon_pkey PRIMARY KEY (id),
  CONSTRAINT WorkingOn_FK_Contact_id_fkey FOREIGN KEY (fk_contact_id) REFERENCES public.contacts(id),
  CONSTRAINT WorkingOn_FK_Object_id_fkey FOREIGN KEY (fk_object_id) REFERENCES public.object(id)
);

--VIEW 1
DROP VIEW IF EXISTS public.contact_object_history CASCADE;
CREATE OR REPLACE VIEW public.contact_object_history AS
SELECT
  w.id               AS workingon_id,
  w.fk_contact_id    AS contact_id,
  w.created_at       AS from_date,
  NULL::timestamptz  AS to_date,
  o.id               AS object_id,     
  o.name             AS object_name,  
  r.rating,
  r.reviewtext
FROM public.workingon w
JOIN public.object o
  ON o.id = w.fk_object_id
LEFT JOIN public.review r
  ON r.fk_workingon_id = w.id;

--VIEW 2
CREATE OR REPLACE VIEW contacts_with_details AS
SELECT
  c.*,
  (
    SELECT string_agg(s.name, ', ')
    FROM hasskills hs
    JOIN skills s ON hs.fk_skills_id = s.id
    WHERE hs.fk_contacts_id = c.id
  ) AS roles,
  (
    SELECT string_agg(o.name, ', ')
    FROM workingon wo
    JOIN object o ON wo.fk_object_id = o.id
    WHERE wo.fk_contact_id = c.id
  ) AS objects
FROM
  contacts c;

--VIEW 3
CREATE VIEW object_with_workers AS
SELECT
 o.id,
 o.name,
 o.location,
 o.description,
 o.isactive,
 o.startdate,
 o.enddate,
 c.name AS contact,
 c.id AS contactid,
 w.ispaid AS ispaid
FROM object o
LEFT JOIN workingon w ON o.id = w.fk_object_id
LEFT JOIN contacts c ON w.fk_contact_id = c.id;

--CREATE CONTACT
CREATE OR REPLACE FUNCTION public.create_full_contact(
    p_name        text,
    p_number      text,
    p_email       text,
    p_birthday    date,
    p_roles_str   text,
    p_objects_arr bigint[],
    p_workingfrom date,
    p_workingto   date,
    p_cost        real,
    p_user_id     uuid,
    p_team_id     bigint
)
RETURNS bigint AS $$
DECLARE
    v_contact_id bigint;
    v_role_name  text;
    v_object_id  bigint;
    v_skill_id   smallint;
    v_skill_user_id bigint;
    v_skill_team_id bigint;
BEGIN
    INSERT INTO contacts (
        name,
        number,
        email,
        birthday,
        cost,
        isfavorite,
        isblacklist,
        workingfrom,
        workingto,
        user_id,
        team_id,
        isdeleted
    )
    VALUES (
        p_name,
        p_number,
        p_email,
        p_birthday,
        p_cost,
        FALSE,
        FALSE,
        p_workingfrom,
        p_workingto,
        CASE WHEN p_team_id IS NULL THEN p_user_id ELSE NULL END,
        CASE WHEN p_team_id IS NOT NULL THEN p_team_id ELSE NULL END,
        FALSE
    )
    RETURNING id INTO v_contact_id;

    IF p_roles_str IS NOT NULL AND p_roles_str <> '' THEN
        FOREACH v_role_name IN ARRAY string_to_array(p_roles_str, ',')
        LOOP
            v_role_name := trim(v_role_name);
            IF v_role_name <> '' THEN
                v_skill_user_id := CASE WHEN p_team_id IS NULL THEN p_user_id ELSE NULL END;
                v_skill_team_id := CASE WHEN p_team_id IS NOT NULL THEN p_team_id ELSE NULL END;

                SELECT id INTO v_skill_id
                FROM skills
                WHERE name = v_role_name
                  AND (user_id = v_skill_user_id OR user_id IS NULL)
                LIMIT 1;

                IF v_skill_id IS NULL THEN
                    INSERT INTO skills (name, user_id)
                    VALUES (v_role_name, v_skill_user_id)
                    RETURNING id INTO v_skill_id;
                END IF;

                INSERT INTO hasskills (fk_contacts_id, fk_skills_id, user_id)
                VALUES (
                    v_contact_id,
                    v_skill_id,
                    v_skill_user_id
                );

            END IF;
        END LOOP;
    END IF;

    IF p_objects_arr IS NOT NULL AND array_length(p_objects_arr, 1) > 0 THEN
        FOREACH v_object_id IN ARRAY p_objects_arr
        LOOP
            INSERT INTO workingon (
                fk_contact_id,
                fk_object_id,
                user_id,
                ispaid
            )
            VALUES (
                v_contact_id,
                v_object_id,
                CASE WHEN p_team_id IS NULL THEN p_user_id ELSE NULL END,
                TRUE
            );
        END LOOP;
    END IF;

    RETURN v_contact_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.create_full_contact(
    text, text, text, date, text, bigint[], date, date, real, uuid, bigint
) TO authenticated;

--UPDATE CONTACT
CREATE OR REPLACE FUNCTION update_full_contact_with_history(
  p_contact_id bigint,
  p_name text,
  p_number text,
  p_email text,
  p_birthday date,
  p_roles_str text,
  p_workingfrom date,
  p_workingto date,
  p_cost real,
  p_isblacklist boolean,
  p_isfavorite boolean,
  p_user_id uuid,
  p_history jsonb
)
RETURNS void AS $$
DECLARE
  rec RECORD;
  v_object_id bigint;
  v_existing_review_id bigint;
BEGIN
  UPDATE contacts
  SET name = p_name,
      number = p_number,
      email = p_email,
      birthday = p_birthday,
      cost = p_cost,
      workingfrom = p_workingfrom,
      workingto = p_workingto,
      isblacklist = p_isblacklist,
      isfavorite = p_isfavorite
  WHERE id = p_contact_id
    AND user_id = p_user_id;

  FOR rec IN 
    SELECT *
    FROM jsonb_to_recordset(p_history)
      AS t(workingon_id bigint, object_name text, rating smallint, reviewtext text)
  LOOP

    SELECT fk_object_id
      INTO v_object_id
      FROM workingon
      WHERE id = rec.workingon_id;

    UPDATE object
      SET name = rec.object_name
      WHERE id = v_object_id;

    SELECT id INTO v_existing_review_id
      FROM review
      WHERE fk_workingon_id = rec.workingon_id;

    IF v_existing_review_id IS NULL THEN
      INSERT INTO review (fk_workingon_id, rating, reviewtext, user_id)
      VALUES (rec.workingon_id, rec.rating, rec.reviewtext, p_user_id);
    ELSE
      UPDATE review
        SET rating = rec.rating,
            reviewtext = rec.reviewtext
      WHERE id = v_existing_review_id;
    END IF;

  END LOOP;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


--DELETE CONTACT
create or replace function delete_full_contact(p_contact_id bigint)
returns void as $$
begin
  delete from review
  where fk_workingon_id in (
    select id from workingon where fk_contact_id = p_contact_id
  );

  delete from workingon
  where fk_contact_id = p_contact_id;

  delete from hasskills
  where fk_contacts_id = p_contact_id;

  delete from contacts
  where id = p_contact_id;
end;
$$ language plpgsql security definer;

-- TEAM TABLE
CREATE TABLE public.team (
  id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  invite_code TEXT NOT NULL UNIQUE,
  created_by UUID NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- MEMBER_ROLE TABLE
CREATE TABLE public.member_role (
  id SMALLINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name TEXT UNIQUE NOT NULL
);

-- MEMBER_STATUS TABLE
CREATE TABLE public.member_status (
  id SMALLINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name TEXT UNIQUE NOT NULL
);

-- TEAM_MEMBER TABLE
CREATE TABLE public.team_member (
  id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  team_id BIGINT NOT NULL REFERENCES public.team(id),
  user_id BIGINT NOT NULL,
  role_id SMALLINT NOT NULL REFERENCES public.member_role(id),
  status_id SMALLINT NOT NULL REFERENCES public.member_status(id),
  joined_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- MODIFY EXISTING TABLES (if necessary)
ALTER TABLE public.contacts
ADD COLUMN team_id BIGINT NULL REFERENCES public.team(id);

ALTER TABLE public.object
ADD COLUMN team_id BIGINT NULL REFERENCES public.team(id);

create table tasks (
  id uuid primary key default uuid_generate_v4(),
  object_id int references object(id) on delete cascade,
  title text not null,
  is_done boolean default false,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

-- 
alter table tasks disable row level security;
---

--tasks update
alter table tasks add column if not exists repeat_type text check (repeat_type in ('none', 'daily', 'weekly', 'monthly', 'yearly')) default 'none';
alter table tasks add column if not exists repeat_interval int default 1; -- e.g. every 2 weeks
alter table tasks add column if not exists repeat_on_weekdays boolean[] default null; -- e.g. {mon,wed,fri}
alter table tasks add column if not exists repeat_on_month_day int default null; -- e.g. 15th of month
alter table tasks add column if not exists last_completed_at timestamp with time zone default null;
alter table tasks add column if not exists next_due_date timestamp with time zone default null;
---seej√§rel
update tasks set repeat_type = 'none' where repeat_type is null;